## 什么是 Class 加载

上节我们讲了 class 文件，class 文件就是源代码编译后的产物，它只是一个静态的文件，程序运行还需要做点别的工作。我们的程序要运行，从头到尾大约经历这几个步骤：编写代码 - javac 编译成 class 文件 - JVM 读取 class 文件加载到内存中，并转换为自己能处理的格式 - JVM 从程序入口处运行代码 - 运行完毕，结束程序。

那么，**Class 加载（后文称“类加载”）** 就是 JVM 将 class 文件加载到内存中，然后对数据进行校验、转换解析和初始化。

## 什么时候开始类加载

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading) - 验证(Verification) - 准备(Preparation) - 解析(Resolution) - 初始化(Initialization) - 使用(Using) - 卸载(Unloading) 7 个阶段。其中验证、准备、解析 3 个部分统称为连接(Linking)。

![2020072117jBJXLp8585a4e6.png](http://img.dotleo.cn/blog/2020072117jBJXLp8585a4e6.png)

类加载过程中的加载、验证、准备、初始化和卸载都是按照顺序按部就班的开始，而解析阶段不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。另外，这里提到的是按部就班的 **开始**，而不是按部就班的“进行”或“完成”，因为这些阶段通常是互相交叉地混合式进行的。

那么，什么时候开始第一个阶段：加载？Java 虚拟机并没有进行强制约束，这点可以交给虚拟机具体实现来自由把握。但对于初始化阶段，虚拟机规范则有严格的规定，规定 **有且只有** 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前）。

1. 遇到 new, getstatic, putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行初始化过，则需要先触发初始化。生成这 4 条指令的最常见 Java 代码场景是：使用 new 实例化对象、读取或设置一个静态字段(**被 final 修饰的会在编译器把结果放入常量池的静态字段除外**)，以及调用了一个类的静态方法的时候。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的那个类)，虚拟机会先初始化该类。
5. 动态语言支持 `java.lang.invoke.MethodHandle` 解析的结果为 REF_getstatic、REF_putStatic、REF_invokeStatic 的方法句柄时，则需要先触发其初始化。

除此之外，所有引用类的方式都不会触发初始化，称为 **被动引用** 。下面介绍 3 种被动引用的例子。举例之前，我们先来聊聊如何知道一个类被初始化了，类加载过程中的初始化阶段会调用 `<clinit>()`，它会执行静态代码块，所以我们只要在里面输出就可以监听到 **类被初始化** 了（注意不是对象被初始化）。

```java
/**
 * 被动引用示例一：
 * 通过子类引用父类的静态字段，不会导致子类初始化。
 */

class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```

```java
/**
 * 被动引用示例二：
 * 通过数组定义来引用类，不会触发此类的初始化。原因在于创建数组由字节码指令newarray触发。
 * 
 * 由于篇幅原因，SuperClass类见上段代码。
 */
public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```

```java
/**
 * 被动引用示例三：
 * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。
 */
class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final String HELLO_WORLD = "hello, world";
}

public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLO_WORLD);
    }
}
```

## 类加载的过程

接下来我们聊聊 Java 虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。

### 加载

“加载”是“类加载”(Class Loading)过程的一个阶段，大家不要混淆。在加载阶段，主要干 3 件事：

1. 通过一个类的 **全限定名** 来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结果转化为 **方法区的运行时数据结构**。
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

白话点说，就是创建两块内存，一块把二进制的 class 文件读取、转换后放入。然后在另一块内存中生成一个 Class 类的对象，指向第一块内存。

这其中的第一步读取二进制字节流，不仅仅可以是本地的一个 class 文件。也可以是 zip 包，最常见的如 jar、war 包。可以是通过动态代理技术，为特定代理类生成的二进制字节流。总之这部分主要靠类加载器的实现。

加载完成后，二进制字节流将按照虚拟机所需要的格式存储在方法区中。而 Class 类的对象在 HotSpot 虚拟机中也会存到方法区中。

**注意** ：当加载阶段第 1 步执行完第 2 步执行前，会有一个验证过程（类加载过程的下一个阶段，后面会讲到）。因此我们可以看出，加载还没结束、验证就已经开始了（加载在验证之前开始，但不是按顺序执行或完成，有些步骤是穿插执行的）。

### 验证

验证是连接阶段的第一步，这个阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机自身的安全。

Java 语言本身是相对安全的语言，使用纯粹 Java 代码无法做到访问数组边界以外的数据、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面说过，Class 文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生 Class 文件。因此，如果虚拟机不检查输入的字节流，可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。

大致分为 4 个检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

#### 文件格式验证

主要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。可能包括下面几个验证点：

- 是否以魔数 0xCAFEBABE 开头
- 主、次版本号是否在当前虚拟机处理范围内
- 常量池的常量是否有不被支持的类型
- ...

可以看出，基本上就是验证 **字节流是否符合 Class 文件格式规范** 。

通过了文件格式验证后，保证格式上符合 Java 类型信息的要求。字节流才会进入内存的方法区存储，所以 **后面 3 个阶段全部是基于方法区的存储结构进行的，不会再操作字节流了** 。


#### 元数据验证

主要对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。可能包括下面几个验证点：

- 是否存在父类
- 是否继承了不允许继承的类(被 final 修饰)
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段)
- ...

可以看出，基本上就是验证 **Java 语法是否有错误（过程相对比较静态）**，保证不存在不符合 Java 语法规范的元数据信息。

#### 字节码验证

这个动作是最复杂的一个，主要目的是通过数据流和控制流分析，确定程序字节码是合法的、合乎逻辑的。**第 2 个动作是验证元数据信息中的数据类型，这个阶段是对类的方法体进行校验分析** ，保证被验证类的方法在运行时不会做出危害虚拟机的事件。

- 保证任意时刻操作数栈的数据类型与指令码的操作码类型一致
- 保证跳转指令不会跳转到方法体外的字节指令上
- ...

可以看出，基本上就是 **分析字节码指令的正确性(过程相对比较动态，需要进行流程分析）** ，保证方法体不会操作不当导致危害虚拟机的事件。

#### 符号引用验证

这个验证动作发生在虚拟机将 **符号引用转化为直接引用（解析阶段）** 的时候，可以看做是对类自身以外的信息进行匹配性验证，通常需要校验以下内容：

- 符号引用中通过字符串描述的全限定名是否能找到相应的类
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
- ...

可以看出，主要验证 **符号引用是否存在、合法** ，确保解析阶段正常运行。

### 准备

准备阶段是正式为 **类变量分配内存空间** 并设置 **类变量初始值** 的阶段，这些变量所使用的内存都将在方法区中进行分配。这里有两个概念容易混淆，首先，分配内存空间的仅包括类变量（被 static 修饰的变量），而不包括实例变量。其次，这里说的初始值通常指数据类型的“零值”，而不是我们指定的数值。

```java
public static int value = 123;
```

这段代码在准备阶段完成后，value 为 0 而不是 123，赋值 123 在初始化阶段 `<clinit>()` 中进行。

下图列出了 Java 中所有基本数据类型的零值。

![202007212123LRIQ07da2435.png](http://img.dotleo.cn/blog/202007212123LRIQ07da2435.png)

**特殊的** ，如果字段的字段属性表中存在 ConstantVale 属性，那么在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义为：

```java
public static final int value = 123;
```

编译时 javac 会为 value 生成一个 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。

### 解析

解析阶段是虚拟机将常量池内的 **符号引用** 代替为 **直接引用** 的过程。

什么是符号引用？符号引用就是用符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标就可以。白话的讲：我的类中有一个 String 类型的字段，JVM 使用 `Ljava/lang/String` 表示 String 类型, 那 `Ljava/lang/String` 就是一个符号引用，它是一个 JVM 能够识别的符号。

什么是直接引用？白话的讲：直接引用就是通过这个引用，JVM 能找到对应的内存地址。比如上面的符号引用 `Ljava/lang/String`，在未解析之前只知道我这个类有一个 String 类型的字段，但运行时需要用到 String 类型的方法，此时 JVM 就要找到 String 类型对应的那块内存去访问，能够访问到内存中 String 的引用就是直接引用。

虚拟机并未规定解析阶段发生的具体时间，只要求了在执行 `anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic` 这 16 个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析。**所以虚拟机实现可以根据需求来判断到底是在类加载时就对常量池中的符号引用进行解析，还是等到一个符号引用要被使用前才去解析它。**

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_MethodType_info, CONSTANT_MethodHandle_info 和 CONSTANT_InvokeDynamic_info 7 种常量类型。我们这里先聊前 4 种引用的解析过程，方便大家理解这个过程。

#### 类和接口解析

假设当前代码所处的类为 D，要把一个未解析过的符号引用 N 解析为一个类或者接口 C 的直接引用，大约有以下 3 个步骤：

1. 如果 C 不是一个数组类型，虚拟机将代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，又可能触发其他类的加载动作，比如加载这个类的父类或实现的接口。一旦这个过程出现任何异常，解析过程就宣布失败。
2. 如果 C 是一个数组类型，并且数组元素类型为对象，假设符号引用 N 类似于 `[Ljava/lang/Integer`，那么就需要先去加载元素类型 `Ljava/lang/Integer`，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
3. 如果上面的步骤没有异常发生，那么 C 在虚拟机中已经是一个有效的类或接口了，可以直接将符号引用 N 解析为直接引用。但在此之前，会进行符号引用验证(验证的符号引用验证)，确认 D 是否剧本 C 的访问权限。如果发现具备，将会抛出 `java.lang.IllegalAccessError` 异常。

#### 字段解析

要解析一个未被解析过的字段符号引用，首先将会对字段表内该 CONSTANT_Class_info 符号进行解析，也就是字段所属的类或者接口的符号引用。如果在这个过程中出现任何异常，都会导致字段符号引用解析的失败。如果解析成功的完成，那么这个字段所属的类或者接口用 C 表示，虚拟机会对 C 进行字段的搜索。

1. 如果 C 本身就包含了简单名称和字段描述符两个都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果在 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符两个都于目标匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果 C 不是 java.lang.Object 的话，将会按照继承关系从下往上搜索其父类，，如果接口中包含了简单名称和字段描述符两个都于目标匹配的字段，则返回这个字段的直接引用，查找结束。4. 否则，查找失败，抛出 `java.lang.NoSuchFieldError` 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对该字段的访问权限，将抛出 `java.lang.IllegalAccessError` 异常。

#### 类方法解析

类方法和接口方法符号引用的常量类型定义是分开的，`CONSTANT_Methodref_info` 代表类接口方法，`CONSTANT_InterfaceMethodref_info` 代表接口方法。

类方法解析第一步和字段解析一样，也需要先对类方法表内该 `CONSTANT_Methodref_info` 符号进行解析，如果解析成功，我们用 C 表示这个类，接下来虚拟机将按照如下步骤进行后续的类方法搜索。

1. 在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，有则返回直接内存，查找结束。
2. 否则，递归查找类 C 的父类，有则返回直接内存，查找结束。
3. 否则，递归查找类 C 实现的接口及它们的父接口中查找，有则返回直接内存，查找结束。
4. 否则，宣告方法查找失败，抛出 `java.lang.NoSuchMethodError`。

如果查找过程成功返回了引用，将会对这个方法进行权限验证，如果发现不具备对该方法的访问权限，将抛出 `java.lang.IllegalAccessError` 异常。

#### 接口方法解析

基本和类方法解析相似，先解析 `CONSTANT_Methodref_info` 符号，如果解析成功，我们用 C 表示这个接口，接下来虚拟机将按照如下步骤进行后续的接口方法搜索。

1. 在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，有则返回直接内存，查找结束。
2. 否则，递归查找接口 C 实现的接口及它们的父接口中查找，有则返回直接内存，查找结束。
3. 否则，宣告方法查找失败，抛出 `java.lang.NoSuchMethodError`。

因为接口的方法都是 public，所以不会抛出 `java.lang.IllegalAccessError` 异常。

上面这些过程我照抄书都抄累了，而且我看第一遍的时候觉得看不懂直接跳过了，为了你能懂，白话一下上面这些过程吧。查找类的直接地址是，如果类是对象就由本类的类加载器加载后返回直接地址，如果是数组则加载数组元素（如果元素为对象）后由虚拟机生成直接地址。如果是字段，因为字段属于类，所以先需要先查找类，然后找该类中时候有匹配的字段，没有递归找父类和父接口。类方法和接口方法类似，大家自己琢磨。

### 初始化

初始化阶段是类加载的最后一步，也是除了加载阶段程序员可以通过自定义类加载器参与外，其余动作都是虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。初始化阶段其实就是执行 `<clinit>()` 的过程。

`<clinit>()` 方法由编译器自动收集类中的所有类变量的赋值动作和静态代码块(static{}块)中的语句产生的，会按照语句在源文件中的顺序排列。值得注意的是，静态代码块可以赋值和访问定义在它之前的类变量。但只能赋值定义在其后的类变量，不能访问它。

```java
public class Test {
    static {
        i = 0; // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译会提示“非法向前引用”
    }

    static int i = 1;
}
```

改为如下就可以正常运行了：

```java
public class Test {
    static int i = 1;

    static {
        i = 0; // 给变量赋值可以正常编译通过
        System.out.print(i); // 打印i的值0
    }

}
```

为什么是 0 呢？这其中包括这样几个过程：首先在准备阶段 i 会被赋值为 0(int 类型的零值)，然后进入到初始化阶段后，因为编译时期生成的 `<clinit>()` 方法根据代码顺序会让类变量赋值语句先于静态代码块，因此先执行 `static int i = 1;`，然后执行同步代码块中的 `i = 0`。

`<clinit>()` 的特点如下：

- 虚拟机会保证子类的 `<clinit>()` 方法执行前，已经执行完父类的 `<clinit>()` 方法。意味着父类的静态代码块优先于子类的静态代码块执行。
- 如果一个类没有类变量和静态代码块，不会生成 `<clinit>()`。
- 接口中不能使用静态代码块，但接口中可以有类变量赋值，因此也会生成 `<clinit>()`。
- **虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境下被正确加锁、同步** ，如果多个线程同时去初始化一个类，只有一个线程去执行，其他线程都需要被阻塞等待。如果一个类的 `<clinit>()` 中有耗时很长的操作，可能会造成多个线程阻塞。

### 卸载

**卸载并不是类加载的过程** ，但它是类的生命周期中的一环，因此这里也聊一下。当一个类的 Class 对象不再被引用(即不可达)时，Class 对象就会结束生命周期，类在方法区内的数据也会被卸载，从而结束类的生命周期。

常见的对 Class 对象的引用有：

- 类加载器和 Class 对象相互引用。在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器。调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。因此可见，Class 实例和加载它的加载器之间为双向关联关系。
- 类实例引用了 Class 对象，在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 Java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。

虚拟机规定了类卸载的时机：

1. 该类所有的实例都已经被 GC，也就是 JVM 中不存在该 Class 的任何实例。
2. 加载该类的 ClassLoader 已经被 GC。
3. 该类的 Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。

通过类卸载的时机可以看到，其中的 1、3 还是可以达到的，但对于一个由系统类加载器（后文会提到，包括根类加载器、扩展类加载器和系统类加载器）加载的类，类加载器和 Class 对象保持着相互引用。因此如果需要卸载，必须类加载器被 GC，但系统类加载器在整个虚拟机的生命周期都不会被 GC。因此，**由 Java 虚拟机自带的系统类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。**

但自定义类加载器加载的 Class，会随着 ClassLoader 的 GC、实例对象的 GC 且没有任何地方引用时，在 GC 时会被卸载。

### 大致顺序

以下是我自己总结的，不一定准确。一是为了说明这些阶段并非顺序执行，只是顺序开始。二是为了帮助理解这些过程。如果有任何错误，还请批评指正。

```
-- 加载(通过全类名获取二进制字节流)
--- 验证(类文件验证，验证是否符合类文件格式)
-- 加载(将字节流存储到方法区中)
-- 加载(生成Class类型的对象)
--- 验证(元数据验证，验证是否符合Java语法规范)
--- 验证(字节码验证，分析验证方法体是否符合规范)
---- 准备
--- 验证(如果需要执行，符号引用验证，确保解析的正常执行)
----- 解析(如果需要执行)
------ 初始化
```

白话点回答面试官：类加载分为 5 个阶段，加载、验证、准备、解析和初始化，验证、准备、解析又称为连接。其中，加载分为 3 步，首先将 class 文件以字节流的方式加载到内存中，然后转化为虚拟机能懂的数据结构存储在方法区，最后由一个 Class 类对象指向该方法区内存。验证主要有 4 种，Class 文件结构验证、Java 语法及数据类型验证、字节码指令的验证（方法体的验证）和对符合引用转化为直接引用时的一些符号信息、权限进行验证。准备主要是为类变量分配空间且赋零值。解析主要是将符号引用转化为直接引用。初始化则为执行 `<clinit>()` 方法，该方法是类变量赋值语句和静态代码块生成而来。

## 总结

这节内容，我们主要聊了从大局什么是类加载，什么时候开始类加载，以及类加载的 5 个过程，类的卸载。下节会详细讲类加载器、双亲委派模型及源码分析、如何打破双亲委派模型、JDBC 的类加载机制、tomcat 的类加载机制等。

## 参考文章

1. 《深入理解 Java 虚拟机 第 2 版》 - 周志明著
2. [JVM 中类的卸载机制_Java 我人生的技术博客-CSDN 博客_java jvm 卸载类](https://blog.csdn.net/chenleixing/article/details/47099771)
3. [双亲委派模型：大厂高频面试题，轻松搞定](https://mp.weixin.qq.com/s/Dnr1jLebvBUHnziZzSfcrA)

