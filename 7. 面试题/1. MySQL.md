> 特别说明：本文为笔记，文中主要整理自己的知识点，很多图片和思路来自一些付费课程、网络博客，如果有侵权问题，请联系删除。

## MySQL 架构

Server 层：

- 查询缓存
- 连接器
- 解析器
- 优化器
- 执行器

存储引擎层：

- 存储引擎

## MySQL 查询流程

### order by 是怎样工作的

> 《MySQL 实战 45 讲 第 16 讲》

#### order by 的排序大体分为 3 种

1. 无需排序，order by 列有索引且该索引内被使用
1. 全字段排序，order by 列没有索引，查询字段较少小于一个限定值(max_length_for_sort_data)时
   - sort_buff 能够加载所有的排序数据，会先创建一个 sort_buff，确定放入 x, y, z 字段；然后遍历从表中查询出符合条件记录的 x, y, z 字段；对 sort_buff 中的数据进行 **快速排序**，然后返回符合条件的数据。
   - sort_buff 不能加载所有排序的数据，则会借助外部磁盘进行排序，此时会将数据进行拆分存储后对每个文件进行排序，然后合并（归并排序）。
1. rowid 排序，order by 列没有索引，查询字段又比较多超过了限定值(max_length_for_sort_data)时
   - sort_buff 能够加载所有的排序数据，会先创建一个 sort_buff， 确定放入排序列和主键 id；然后遍历从表中查询出符合条件的记录排序字段和主键 id；对 sort_buff 中的数据进行快速排序；然后通过排序好数据的主键 id 去主索引中查询相关字段后返回。
   - sort_buff 不能加载所有排序的数据，则会借助外部磁盘进行排序，此时会将数据进行拆分存储后对每个文件进行排序，然后合并（归并排序）。

对于 **InnoDB** 来说，在小于 `max_length_for_sort_data` 的情况下，会优先选择全字段排序，因为可以减少随机访问的次数提升效率。但对于内存表或使用了临时表（临时表使用 memory 引擎）的结果进行排序时，通常会采用 rowid 的排序方式。

#### 如何为 order by 语句简历索引

`select field3 from temp where field1 = a order by field2`, 此时，我们可以给 `(field1, field2)` 建立联合索引，此时就可以通过这个索引查询了，但此时 explain 的 extra 字段为 `usign index condition`，如果我们需要进一步提升，可以对 `(field3, field1, field2)` 建立联合索引，此时可以直接通过覆盖索引查找到排序好的数据。

如果有这样的语句，`select field3 from temp where field1 in (a, b) order by field2`, 此时系统又不能命中索引，因此我们需要通过自己的程序，分别查询 `select field3 from temp where field1 = a order by field2` 和 `select field3 from temp where field1 = b order by field2` 的结果，然后利用归并排序的思想，自己在内存中进行排序。

## MySQL 更新流程

//TODO 串联如下概念

- redo logo
- undo logo
- change buffer

### 两阶段提交时出现 crash

![2020091612syzQhp8fe9f735.png](http://img.dotleo.cn/blog/2020091612syzQhp8fe9f735.png)

在时刻 A，写入了 redolog 未写入 binlog，处于 prepare 阶段之后，写 binlog 之前，此时 binlog 还没有写，redolog 也还没有提交。发生了崩溃，崩溃恢复的时候，事务会回滚，因为 binlog 没有写入也不会影响从库。

在时刻 B，写入了 redolog 也写入了 binlog 中，但 redolog 还没有 commit，此时发生了崩溃，崩溃恢复的时候，redolog 里的事务只有完整的 prepare，然后判断 binlog 中的日志如果是完整的，则提交事务；如果不完整，则回滚。

#### 那如何判断 binlog 中的日志是完整的呢

因为 binlog 有结束标识，比如 statement 格式的 binlog，最后会有一个 commit；row 格式的 binlog 最后会有一个 XID event。MySQL 5.6.2 版本之后，还引入了 binlog-checksum 机制来保证 binlog 的正确性。

#### redolog 和 binlog 是如何关联起来的

他们有一个共同的数据字段，XID。崩溃恢复时，会顺序扫描 redolog：

- 如果碰到既有 prepare，又有 commit 的 redolog，就直接提交。
- 如果碰到只有 prepare、而没有 commit 的 redolog，就拿着 XID 去 binlog 找对应的事务。

#### 为什么需要两阶段提交

redolog 提交后就不能回滚，因为会影响后面的事务更新。因此如果不采用两阶段提交的方式，redolog 提交后，可能 binlog 写入不成功，也无法回滚。


## MySQL 删除

## MySQL 锁

通常为了防止死锁等，推荐使用一次封锁的方式加锁，就是在方法开始的阶段，已经预先知道哪些数据需要加锁，将它们全部锁住，在方法执行完成后，再全部解锁。这种方式不太适合数据库，因为在事务开始时，数据库并不知道接下来会操作到哪些数据。

因此，MySQL 遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以称为两阶段锁）。

- 加锁阶段：加锁阶段，对任何数据读操作之前要申请并获得 S 锁（共享锁），在写数据之前要申请并获得 X 锁（排它锁）。加锁不成功就进入等待状态，直到加锁成功。
- 解锁阶段：事务释放了一个封锁后，事务进行解锁阶段，这个阶段只能进行解锁不能再进行加锁操作。

> 《MySQL 实战 45 讲 第 19 讲》

### 锁的种类

#### 表级别锁

#### Metadata Lock

#### 行级别锁

//TODO 待完成

### 语句执行变慢

可以使用 `show processlist` 命令查看当前执行语句的状态。

#### 等 MDL 锁



#### 等 flush

#### 等行锁

#### 慢查询



## MySQL 事务

> [Innodb 中的事务隔离级别和锁的关系 - 美团技术团队](https://tech.meituan.com/2014/08/20/innodb-lock.html)
>
> [一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点 - 风的姿态 - 博客园](https://www.cnblogs.com/fengzheng/p/12557762.html)

### 事务隔离级别

- 读未提交（Read uncommitted）：允许脏读，也就是可以读取到其他会话中未提交的事务。
- 读已提交（Read committed）：只能读取其他事务中已经提交的事务。Oracle 中默认是这个级别。
- 可重复读（Repeatable read）：在同一个事务内的查询都和事务开始时刻一致，InnoDB 默认级别。
- 串行化读（Serializable）：完全串行化读，每次读取都需要获取表级共享锁，读写相互都会阻塞。

### 各事务级别存在的问题

- 脏读，是指该事务读到其他事务还没有提交的改变，读未提交级别出现，读已提交及以上级别已经解决。
- 不可重复读，是指该事务在执行期间，两次读到某个数据的值不一样的情况，一般出现在 **更新** 操作，读已提交级别出现，可重复读及以上级别已经解决。
- 幻读，是指该事务在执行期间，在第二次读取时出现了第一次读取时没有的数据，一般出现在 **插入** 操作，读已提交级别出现，可重复读及以上级别已经解决，注意 MySQL 在可重复读级别已经解决了幻读问题。

### 事务级别的实现方式

#### 读未提交

读未提交（后简称 RU），一般数据库不会用这种级别，该级别对 **任何操作都不会加锁** 。

#### 读已提交

读已提交（后简称 RC），Oracle 默认级别。该级别读时不加锁，增删改时会加锁。

对于有索引的列更新，会直接 **给数据行加锁**。对于没有索引的列，存储引擎层会 **将所有的记录加锁** 返回，MySQL Server 进行过滤，把 **不符合条件的行 unlock** 。

#### 可重复读

已重复读。对于快照读，**使用 MVCC 控制和 undolog 即可避免幻读**，对于当前读，**使用 next-key 锁**，即通过行锁和间隙锁在加锁。

可以这么说，在 Innodb 的 RR 级别下，**MVCC 完全解决了不可重复读** 问题，通过历史数据的方式屏蔽了部分幻读问题，但没有解决所有的幻读问题。因此在当前读的场景下，补充使用了 next-key lock 解决了幻读问题。

关于间隙锁，需要注意的有：

1. 跟间隙锁冲突的是插入间隙的插入操作，间隙锁之间不冲突。
1. 间隙锁是一个左开右闭的区间（行锁是一个值，间隙锁是一个开区间，那么合起来的 next-key 是一个左开右闭的区间）

关于间隙锁的问题及解决方案：

1. 容易引发死锁，MySQL 自动的死锁检测机制，会让其中的一个持有间隙锁的 session 报错。
1. 影响并发度，根据业务，可以使用读已提交，但不能保证可重复读，此时 binlog 模式应该为 row 模式。

![2020091719eHjkYpc5adb41c.png](http://img.dotleo.cn/blog/2020091719eHjkYpc5adb41c.png)

例如上图中，之所以会死锁。是因为在 session A 加了间隙锁后， session B 加了间隙锁时因为间隙锁本身不冲突，所以也可以成功加间隙锁。之后，当两条插入语句执行时，每个 session 都拥有各自的间隙锁，间隙锁和插入冲突导致死锁。

#### 串行化读

串行化读比较简单，**读加共享锁，写加排它锁**，读写互斥使用悲观锁的理论，实现简单，数据更安全，但并发能力差。

### 当前读和快照读

当前读：读取最新的提交记录，并且对读取记录进行加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。

比如要 update 一条记录，但另一个事务删除了这条数据并做了提交，如果不加锁的情况下就会发生冲突。所以在变更记录时都是当前读，得到最新的信息并且锁定相应的记录。

常见的当前读有：

```sql
select ... lock in share mode //共享读锁
select ... for update
insert
update
delete
```

快照读：读取数据的可见版本（可能是过期数据），不用加锁。

在事务中，简单的 select 语句就开启了一个快照读。

#### 为什么需要当前读

因为在比如 update 这种语句中，我们需要读到最新已提交的数据，不能基于历史数据做变更，这样会导致冲突。

## MySQL 索引

索引是一种数据结构，帮助我们快速的查找到数据，像书籍中的目录一样。

### MySQL 索引的数据结构

1. Hash
1. B+ Tree

InnoDB 默认使用 B+ Tree。

Hash 索引是对值进行 hash 后通过 hash 值查找位置存储，读取时一般通过 hash 值能很快找到存储位置。但对于范围查询、排序等却不适用，因为不是顺序存储。B+ Tree 是顺序存储，因此对于范围查询是几乎是顺序读取，且对于个值查询是 O(lgn) 的时间复杂度。

索引是可以自己选择的，因此在一些通过值查询的情况下，我们可以选择使用 hash 索引。在存在范围查询、排序等场景下使用 B+ Tree。

InnoDB 存在“自适应 hash”，在一些频繁查询的数据上，存储引擎会产生用户无感知的 hash 索引。

### 为什么使用 B+ Tree

常见的树和它的对比：

- 二叉搜索树，二叉搜索树可能存在斜树的可能
- 红黑树，是比较好的二叉排序树，但是因为二叉导致数据量大事层数太高，需要访问的磁盘次数太多。
- B+ Tree，是多路查找树，通常 2~3 层就可以存下千万级别的数据。

### 聚簇索引和二级索引

聚簇索引（一级索引 / 主索引）：

![2020091719PfeVbY28a1701c.png](http://img.dotleo.cn/blog/2020091719PfeVbY28a1701c.png)

二级索引：

![2020091719P5wnhU3f1c5940.png](http://img.dotleo.cn/blog/2020091719P5wnhU3f1c5940.png)

以上是在 InnoDB 中的示意图，聚簇索引中，非叶子结点存储主键 ID，叶子结点存储数据。二级索引中，叶子结点存储的是索引内容和主键 ID。

在 MyISAM 中，主键索引和二级索引基本一致，区别在于主键索引不可以存储重复元素，二级索引可以重复。相同点是叶子结点存储索引数据和数据的物理地址。

InnoDB 相较于 MyISAM，有聚簇索引的概念。那么聚簇索引有什么优点呢？优点在于聚簇索引的叶子结点直接存储的是数据，而非聚簇索引的叶子结点存储的数据的地址，还需要通过地址去查找数据，显然聚簇索引的效率更高。

### 常见的缓存匹配规则



### 覆盖索引

覆盖索引是指，查询语句中的条件、查询字段等，在索引中都存在，直接通过索引查询到了需要返回的所有内容，不需要通过主键索引进行回查。

### 索引下推

MySQL 5.6 对索引的重大优化。



### 创建联合索引

### 如何查看一个语句索引的使用情况

使用 `explain` 查询语句的执行计划。

> As of MySQL 8.0.12, extended information is available for SELECT, DELETE, INSERT, REPLACE, and UPDATE statements. Prior to 8.0.12, extended information is available only for SELECT statements.

查询结果中包括了以下几个重要字段：

key:

这个字段显而易见，但又很重要。可以用来查看执行计划中使用到的索引是哪个。

type:

- ALL : 全表扫描
- index : 全索引扫描
- range : 索引范围扫描，比索引全扫描要好很多。其中常见的有 in 或者 or，其中 in 比 or 性能好很多
- ref : 这是一种索引查找，即返回通过比较索引和某个值相等返回行，它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类访问在非唯一性索引或者唯一索引的非唯一性前缀时发生。
- eq_ref : 基本同上，不过最多只有一个匹配行。
- const, system : 表中最多有一个匹配行，一般出现在根据 primary key 或 unique key查询的情况。因为只匹配一行数据，所以很快。
- NULL : 执行阶段用不着查表或者索引。比如 `explain select 1;`

extra:

- using where : MySQL 服务器将在存储引擎检索行后进行服务器进行过滤
- using temporary : 需要使用临时表来存储结果集，一般用于排序和分组
- using filesort : 需要进行排序操作（无法通过索引排序的排序操作）
- using index condition : 使用了索引下推
- using index : 使用覆盖索引

### 什么情况下，明明创建了索引却没有使用索引

索引的选择是在优化器中进行的，优化器大概分为以下几个步骤：

1. 根据查询条件，找到所有可能用的索引
1. 计算全表扫描的代价，一般为扫描的行数
1. 计算使用不同索引的代价
1. 通过对比，选择代价最小的索引

但因为以上这些操作都是通过估算得到的，因此可能实际选择的索引并非最优，或者可能在有索引的情况下通过全表扫描的方式。

处理的方式可以是通过强制指定索引，或者去优化语句等。

### 索引失效

- 对字段进行函数计算时，不能使用索引
- 隐式类型的转换，MySQL 在进行字符串和数字比较时，会把字符串转换为数字。假设即使 field1 为 varchar 类型且有索引，`where field1 = 1` 也不会走索引，因为在 MySQL 中会把字符串转换为数字，所以语句可能变为 `CAST(field1 AS signed int) = 1`，此时就不会使用索引。但如果 field1 为 int 且有索引，`where field1 = '1'` 还是会走索引，因为会将 `'1'` 转换为数字 1，并不会使索引失效
- 隐式的字符编码转换也会带来索引失效，一般出现在两表联查时，字符编码不一致的情况。

### MySQL 中的临时表是什么存储引擎

- 临时表在小于一个可设置的阈值时，为 Memory 引擎的表。
- 临时表在大于这个可设置的阈值时，为 InnoDB 引擎的表，因为需要借助外部磁盘存储。

### 不添加主键会怎样

不添加主键，InnoDB 会进行如下判断并生成 `_rowid` 作为主键：

1. 如果表中有非空的整形唯一索引，则该列会被设置为 `_rowid` 。
1. 否则，自动生成一个 6 字节的 rowid 来作为 `_rowid` 。

当然，如果我们制定了主键，则 `_rowid` 等于主键。

我们可以通过 `_rowid` 字段查询，比如 `select _rowid from table`。

## MySQL 日志

## MySQL 主备

## MySQL 读写分离

## MySQL 分库分表

## 参考文章

1. [一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点 - 风的姿态 - 博客园](https://www.cnblogs.com/fengzheng/p/12557762.html)
1. [Innodb 中的事务隔离级别和锁的关系 - 美团技术团队](https://tech.meituan.com/2014/08/20/innodb-lock.html)

