本文几乎所有内容均来自《Redis 设计与实现（第二版） 黄健宏著》 第 15 章 复制，该书基于 Redis 3.0 源码分析，全书中有部分内容已经过时，但该部分内容在 Redis 2.8 有重大改动后，之后维持基本逻辑不变，且作者书写思路清晰，图文并茂，推荐一读。

## 为什么需要主从复制

主从复制是很多数据库必备的功能，有了主从复制我们可以实现以下功能：

- 数据备份，如果单机运行数据库，当数据库出现故障时就可能出现数据的丢失。使用主从复制，我们可以将数据保存一个备份，当其中一个机器出现故障时，可以通过使用其他机器或通过其他机器恢复，这是一种很常见的提高可用性的手段。
- 读写分离，大多数应用都存在读多写少的场景，通过主从复制，我们可以搭建一主多从的集群，实现负载均衡。主结点提供写入服务，从结点提供读取服务，这是一种很常见的提高并发的手段。
- 业务拆分访问，通过主从复制搭建的主从集群，可以让按照业务分别读取不同数据库，保证当某个业务收到流量冲击等影响时，只有相应的数据库出现问题而其他数据库不受牵连，这也是一种常见的提高可用性的手段。

## 使用 slaveof 进行主从复制

Redis 的主从复制主要通过 `slaveof` 命令或者在配置文件（如 `redis.conf` ) 中配置 `SLAVEOF` 实现。

### slaveof 命令

`slaveof <master-host> <master-port>`

slaveof 命令中，第一个参数为 `master-host` ，表示要被复制的主库 host (hostname / ip)，第二个参数为 `master-port` ，表示要被赋值的主库的端口号。

### 配置主从复制

假设我们有两台 redis 实例， master 结点 ip 为 `172.17.0.2` 。

第一种方式，我们进入 slave 结点的客户端， 执行 `slaveof` 命令：

```redis
slaveof 172.17.0.2 6379
```

第二种方式，我们可以在 slave 的配置文件中指定， 在运行 redis 时指定配置文件：

redis.conf 文件添加如下配置

```conf
slaveof 172.17.0.2 6379
```

启动 redis 时，指定配置文件

```bash
redis-server /etc/redis/redis.conf
```

通过以上两种方式我们就可以设置完成主从复制的设置了。

当配置了主从复制模型后，复制双方的数据库的数据将保持一致。概念上将这种现象称为“数据库状态一致”，或者简称“一致”。

比如我们在主库执行以下命令：

```redis
127.0.0.1:6379> set str hello
OK
```

在主服务器上可以获取它：

```redis
127.0.0.1:6379> get str
"hello"
```

在从服务器上也可以获取它：

```redis
127.0.0.1:6380> get str
"hello"
```

如果我们在主服务器上删除它；

```redis
127.0.0.1:6379> del str
(integer) 1
127.0.0.1:6379> get str
(nil)
```

在从服务器上也将无法访问：

```redis
127.0.0.1:6380> get str
(nil)
```

### slaveof 的原理

Redis 的复制功能分为 **同步** (sync) 和 **命令传播** (command propagate) 两个操作：

- 同步操作用于将从服务器的数据库状态 **更新至** 主服务器当前所处的数据库状态。
- 命令传播操作则是在主服务器数据库状态的修改，导致主从状态不一致时，让主从服务器的数据库重新回到一致状态。

当发送 `slaveof` 命令后，要求从服务器复制主服务器时，从服务器会首先执行同步操作，即将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

- 在 Redis 2.8 版本以前，同步操作时，从服务器会发送 `sync` 命令到主服务器进行状态同步。
- 在 Redis 2.8 版本以后，同步操作时，从服务器会发送 `psync` 命令到主服务器进行状态同步。

同步操作执行完成后，主从服务器两者的数据库将达成 **某个时刻** 的一致状态，但这种一致并不会一成不变，每当主服务器执行客户端发送的命令后，主从服务器的数据状态就可能产生差异，因此需要通过 **命令传播** 的方式重新让主从服务器的数据库回到一致状态。

举个例子，假设一个主服务器和一个从服务器刚完成数据库同步操作，他们的数据库都保存了相同的五个建 k1 至 k5，如下图 1 所示。

如果此时，客户端向主服务器发送命令 `DEL k3` ，那么主服务器在执行完成这个 DEL 命令之后，主从服务器的数据库状态将出现不一致：主服务器的数据库已经不再包含 k3 ，如下图 2 所示。

为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：**主服务器会将自己执行的写命令，即造成状态不一致的命令，发送给从服务器执行** ，当从服务器执行完相同的写命令后，主从服务器数据库将再次回到一致状态。如下图 3 所示。

![2020081710nvbh0d4f815217.png](http://img.dotleo.cn/blog/2020081710nvbh0d4f815217.png)

## sync - 旧版本同步功能的实现

在 Redis 2.8 版本以前，同步操作时，从服务器会发送 `sync` 命令到主服务器进行状态同步。

### sync 的实现

当从服务器向主服务器发送了 sync 命令，执行步骤如下：

1. 从服务器向主服务器发送 SYNC 命令。
2. 收到 SYNC 命令后，主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有命令。
3. 主服务器完成 BGSAVE 后，将 RDB 文件发送给从服务器，从服务器接收并加载 RDB 文件，将自己数据库状态 **更新至主服务器执行 BGSAVE 命令时的数据库状态**。
4. 主服务器将记录在缓冲区里面所有的命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态 **更新至主数据库当前所处的状态**。

下图展示了 SYNC 命令执行期间，主从服务器的通信过程：

![2020081711eG5amx1dc19354.png](http://img.dotleo.cn/blog/2020081711eG5amx1dc19354.png)

下表展示了一个主从服务器进行同步的例子：

|   时间| 主服务器  | 从服务器  |
|---|---|---|
| T0  | 服务器启动  | 服务器启动  |
| T1  | 执行 SET k1 v1  |   |
| T2  | 执行 SET k2 v2  |   |
| T3  | 执行 SET k3 v3  |   |
| T4  |   | 向主服务器发送 SYNC 命令  |
|   T5| 接收到从服务器发送的 SYNC 命令，执行 BGSAVE 命令，创建包含 k1, k2, k3 的 RDB 文件，并使用缓冲区记录接下来执行的命令  |   |
| T6  | 执行 SET k4 v4， 并将这个命令记录到缓冲区中  |   |
| T7  | 执行 SET k5 v5， 并将这个命令记录到缓冲区中  |   |
|  T8 | BGSAVE 命令执行完毕，向从服务器发送 RDB 文件  |   |
| T9  |   | 接收并载入主服务器发送的 RDB 文件，获得 k1, k2, k3 三个键  |
| T10  | 向从服务器发送缓冲区中保存的写命令 SET k4 v4 和 SET k5 v5  |   |
| T11  |   | 接收并执行主服务器发来的两个 SET 命令，得到 k4 和 k5 两个键  |
| T12  | 同步完成，主服务器包括 k1, k2, k3, k4, k5  | 同步完成，从服务器包括 k1, k2, k3, k4, k5  |

### sync 的缺陷

在 Redis 中，复制可以分为以下两种情况：

- 初次复制：从服务器 **以前没有复制过任何主服务器**，或者从服务器当前要复制的主服务器 **和上一次复制的主服务器不同**。
- 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，重连后需要继续复制主服务器的情况。

对于初次复制， sync 可以很好的满足。但对于断线后重复制， sync 也可以让主从重新回到一致性状态，但效率极低。

下表展示了一个断线后重复制的例子：

|   时间| 主服务器  | 从服务器  |
|---|---|---|
| T0  | 主从服务器同步完成  | 主从服务器同步完成  |
| T1  | 执行并传播 SET k1 v1  | 执行主服务器传来的 SET k1 v1  |
| T2  | 执行并传播 SET k2 v2  | 执行主服务器传来的 SET k2 v2  |
| ...  | ...  | ...  |
| T10085  | 执行并传播 SET k10085 v10085  |  执行主服务器传来的 SET k10085 v10085 |
| T10086  | 执行并传播 SET k10086 v10086  |  执行主服务器传来的 SET k10086 v10086 |
| T10087  | 主从服务器断开  |  主从服务器断开 |
| T10088  | 执行 SET k10087 v10087 | 断线中，尝试重新连接主服务器  |
| T10089  | 执行 SET k10088 v10088  | 断线中，尝试重新连接主服务器  |
| T10090  | 执行 SET k10089 v10089  | 断线中，尝试重新连接主服务器  |
| T10091  | 主从服务器重新连接  | 主从服务器重新连接  |
| T10092  |   | 向主服务器发送 SYNC 命令  |
| T10093 | 执行 BGSAVE 命令，创建包含 k1 至 k10089 的 RDB 文件，并使用缓冲区记录接下来执行的所有写命令 |   |
| T10094 | BGSAVE 命令执行完毕，向从服务器发送 RDB 文件 |   |
| T10095  |   | 接收并载入主服务器发送的 RDB 文件，获得键 k1 至键 k10089  |
| T10096  | 假设在 BGSAVE 命令执行期间，主服务器没有执行任何写命令，所以跳过发送缓冲区包含的写命令这一步  |   |
| T10097  | 主从服务器再次完成同步  | 主从服务器再次完成同步  |

可以看出，在时间 T10091 , 从服务器终于重新连接上主服务器，因为这是主从状态已经不一致，所以从服务器向主服务器发送 SYNC 命令，而主服务器会创建包含键 k1 至键 k10089 的 RDB 文件发送给从服务器，从服务器通过接收和载入这个 RDB 文件来将自己的数据库更新至主服务器数据库当前所处的状态。

虽然再次发送 SYNC 命令可以让主从服务器重新回到一致性状态，但如果我们仔细研究这个断线复制过程，就会发现 RDB 文件这一步实际上并不是非做不可的：

- 主从服务器在时间 T0 至时间 T10086 中一直处于一致状态，这两个服务器保存的数据大部分都是相同的。
- 从服务器要将自己更新至主服务器当前所处的状态，真正需要的是主从服务器连接中断期间，主服务器添加的 k10087, k10088, k10089 这三个键的数据。
- 可惜的是，SYNC 命令并没有利用上述列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键 k1 至键 k10089 的 RDB 文件。实际上 k1 至 k10086 的数据是没有必要的。

> SYNC 命令是一个非常耗费资源的操作
> 
> 每次执行 SYNC 命令，主从服务器都需要执行以下操作：
>
> 1. 主服务器需要执行 BGSAVE 命令来生成 RDB 文件，这个生成过程会耗费主服务器大量的 CPU、 内存和磁盘 I/O 资源。
> 2. 主服务器需要发送 RDB 文件，这个发送操作会耗费主从服务器的大量网络资源（带宽和流量），会对主服务器响应命令请求的时间产生影响。
> 3. 接收 RDB 文件后需要载入 RDB 文件，载入过程中因为阻塞无法对外提供服务。

## psync - 新版本同步功能的实现

为了解决 SYNC 同步功能在处理断线复制情况时的低效问题，Redis 2.8 及以后版本，使用 PSYNC 命令进行同步。

PSYNC 命令具有完整重同步 (full resynchronization) 和部分重同步 (partial resynchronization) 两种模式：

- 其中完整重同步用于处理初次复制情况，其步骤和 SYNC 命令的执行步骤基本一致，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 而部分重同步则用于处理断线后重复制的情况：当从服务器重连后，如果条件允许，主服务器可以将主服务器连接断开期间执行的写命令发送给从服务器，从服务器接收并执行这些写命令，就可以将数据库更新至主服务器数据库当前所处的状态。

下表展示了一个断线后部分重同步的例子：

| 时间  | 主服务器  |从服务器   |
|---|---|---|
| T0  | 主从服务器同步完成  | 主从服务器同步完成  |
| T1  | 执行并传播 SET k1 v1  | 执行主服务器传来的 SET k1 v1  |
| T2  | 执行并传播 SET k2 v2  | 执行主服务器传来的 SET k2 v2  |
| ...  | ...  | ...  |
| T10085  | 执行并传播 SET k10085 v10085  |  执行主服务器传来的 SET k10085 v10085 |
| T10086  | 执行并传播 SET k10086 v10086  |  执行主服务器传来的 SET k10086 v10086 |
| T10087  | 主从服务器断开  |  主从服务器断开 |
| T10088  | 执行 SET k10087 v10087 | 断线中，尝试重新连接主服务器  |
| T10089  | 执行 SET k10088 v10088  | 断线中，尝试重新连接主服务器  |
| T10090  | 执行 SET k10089 v10089  | 断线中，尝试重新连接主服务器  |
| T10091  | 主从服务器重新连接  | 主从服务器重新连接  |
| T10092  |   | 向主服务器发送 PSYNC 命令  |
|T10093   | 向从服务器返回 +CONTINUE 回复，表示执行部分重同步  |   |
|T10094   |   | 接收 +CONTINUE 回复，准备执行部分重同步  |
|T10095   | 向从服务器发送 SET k10087 v10087, SET k10088 v10088, SET k10089 v10089 三个命令  |   |
|T10096   |   | 接收并执行主服务器传来的三个 SET 命令  |
| T10097  | 主从服务器再次完成同步  | 主从服务器再次完成同步  |

对比 SYNC 命令和 PSYNC 命令处理断线重复制的方法，不难看出，虽然 SYNC 和 PSYNC 都能让断线重连后的主从服务器数据状态达到一致，但执行部分重同步所需要的资源比起 SYNC 命令所需要的资源要少得多，完成同步的速度也快得多。执行 SYNC 需要生成、传送和载入整个 RDB 文件，而部分重同步只需要将从服务器缺少的写命令发送并由从服务器执行即可。

下图展示了 PSYNC 命令执行期间，主从服务器执行部分重同步的通信过程：

![2020081715FWr5NN7da4af2e.png](http://img.dotleo.cn/blog/2020081715FWr5NN7da4af2e.png)

### 部分重同步中三个概念

在介绍 PSYNC 的实现细节之前，我们先来了解部分重同步三个构成部分。

- 主服务器的复制偏移量 (replication offset) 和从服务器的复制偏移量。
- 主服务器的复制积压缓冲区 (replication backlog)。
- 服务器的运行 ID (run id)。

以下将分别介绍这三部分。

#### offset （复制偏移量）

执行复制的双方 —— 主服务器和从服务器会分别维护一个复制偏移量。

- 主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加 N 。
- 从服务器每次收到主服务器传递来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N 。

![2020081716fED3I3d0c7a540.png](http://img.dotleo.cn/blog/2020081716fED3I3d0c7a540.png)

如上图所示，某个时刻主服务器和从服务器的复制偏移量都为 10086 ，如图中 1 所示。当主服务器执行完某条 33 字节的指令后，将自己的偏移量 +33 且将指令传播给从服务器，从服务器接收执行指令并将自己的偏移量 +33 ，如图中 2 所示。

但如果指令传播时，从服务器 1 断开了连接，那么从服务器的偏移量依然维持上次的状态 10086 ，如图中 3 所示。

我们可以通过复制偏移量来判断主从服务器状态是否一致。如果一致，则偏移量相等；如果偏移量不想等，则说明主从状态不一致。

#### backlog （复制积压缓冲区）

backlog 是由主服务器维护的一个 **固定长度 (fixed-size)** 先进先出 (FIFO) 队列，默认大小为 1MB。

当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队列复制到 backlog 里面，如下图所示：

![2020081715QlAux04447810c.png](http://img.dotleo.cn/blog/2020081715QlAux04447810c.png)

因此，主服务器的 backlog 里面会保存一部分最近传播的写命令，并且 backlog 的每个字节都记录相应的复制偏移量，如下表所示。

| 偏移量 | ... | 10087 | 10088 |  10089 |  10090 | 10091 | 10092 |  10093 |  10094 | 10095 | 10096 | 10097 | ... |
|:------:|:---:|:-----:|:-----:|:------:|:------:|:-----:|:-----:|:------:|:------:|:-----:|:-----:|:-----:|:---:|
| 字节值 | ... | `'*'` |   3   | `'\r'` | `'\n'` | `'$'` |   3   | `'\r'` | `'\n'` | `'S'` | `'E'` | `'T'` | ... |

但值得注意的是：backlog 是有一个固定大小的队列，默认 1MB，可以设置。如果主从服务器断开连接期间，写命令大小超过了队列大小，必然会使一些写命令出队列，此时的 backlog 中就不存在全部的断开连接期间的写命令，当从服务器再次重连时，依然不能借助 backlog 实现部分重同步，必须进行完整同步操作。

#### run id

- 每个 Redis 服务器，不论主服务器还是从服务器，都会有自己的运行 ID 。
- 运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符串组成。

### psync 的实现

以上介绍了部分重同步中三个概念，下面来聊聊 PSYNC 如何实现部分重同步及它的使用方法。

PSYNC 命令格式：

```
psync <runid> <offset>
```

其中，runid 为上一次同步的主服务器的 runid，如果之前没有进行过同步则传递 `?` 。 offset 为该从服务器的当前复制偏移量。

PSYNC 命令的调用方法有两种：

1. 如果从服务器以前没有复制过任何主服务器，或者之前执行过 `slaveof no one` 命令（用来取消主从复制功能），那么从服务器算是第一次进行复制，会发送 `psync ? -1` 命令主动请求主服务器进行一次完整重复制。
2. 相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 `psync <runid> <offset>` 命令：其中 runid 是上一次复制的主服务器的运行 ID， 而 offset 则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作：
   - 如果主服务器返回 `+FULLRESYNC <runid> <offset>` 回复，那么表示主服务器将与从服务器执行完整的重同步操作： 其中 runid 是这个主服务器的运行 ID， 从服务器会将这个 ID 保存起来，在下一次发送 PSYNC 命令时使用；而 offset 则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
   - 如果主服务器返回 `+CONTINUE` 回复，那么表示主服务器将与从服务器执行部分重同步，从服务器等待主服务器将 backlog 中缺少的那部分写命令发过来执行就可以。
   - 如果主服务器返回 `-ERR` 回复，那么表示主服务器的版本低于 Redis 2.8 ，它识别不了 PSYNC 命令，并与主服务器执行完整同步操作。

这其中，可能导致主服务器返回 `#FULLRESYNC` 的常见有 3 种情况：

1. 从服务器以前没有复制过任何主服务器，或者之前执行过 `slaveof no one` 命令。
2. 从服务器执行 PSYNC 时，传递的 runid 和当前主服务器的 runid 不匹配，表示当前主服务器已重启或已被替换。
3. backlog 中的写命令不能完全包含从服务器断开期间所有的写命令，即起始偏移量大于 PSYNC 参数中的 offset。

下图展示了从初始状态（从未进行过复制，如图中 1 所示），第一次进行完整复制（如图中 2 所示）和进行一次部分复制（如图中 3 所示）：

![2020081718wLSg96475bfbee.png](http://img.dotleo.cn/blog/2020081718wLSg96475bfbee.png)

## 复制的流程

复制流程除了刚才说的两个主要流程外，还有一些流程也值得我们注意，这里就把所有流程再梳理一遍：

### 步骤 1：设置主服务器的地址和端口

用户通过客户端向从服务器发送 `slaveof 127.0.0.1 6379` 后，从服务器会做两件事：

1. 将主服务器的 host 和 port 进行存储，分别存储为 masterhost 和 masterport 属性。
2. 设置复制状态，因为 SALVEOF 是一个异步命令，因此设置状态后会有专门的时间事件每 1 秒扫描复制任务然后才开始执行。

在保存完这些信息和设置复制状态后，便会向客户端返回 `OK` ，表示复制指令已经接收。正在的工作是等待被时间事件扫描到以后才开始。

### 步骤 2：建立套接字连接

当被扫描到后，复制开始执行。从服务器会和主服务器建立套接字连接，如果建立成功，那么从服务器将会为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收 RDB 文件，以及接收主服务器传播来的写命令。

### 步骤 3：发送 PING 命令确认连接是否正确

当连接创建后，还没有进行任何通信。为了保证以后的操作能顺利进行，从服务器先发送一个 `ping` 命令给主服务器，如果一切 OK 的话，将收到主服务器的 `PONG` 回复。如果失败，则需要重新连接主服务器。

### 步骤 4：身份验证

如果主服务器设置了 masterauth ，则从服务器必须使用 AUTH 命令发送主服务器的连接密码进行校验，成功后进入下一步。

如果主服务器没有设置 masterauth ，则跳过该步骤。

### 步骤 5：通过 REPLCONF 进行信息同步（发送端口信息）

主要同步的从服务器信息包括：

1. 从服务器监听 IP 地址与端口，主服务器以此连接从服务器并同步数据。
2. 从服务器的复制偏移量以及交互时间。

### 步骤 6：发送 PSYNC 命令

发送 PSYNC 命令进行同步的过程，上面已经聊过了，这里就略过了。

### 步骤 7：接收 RDB 文件并载入

从服务器接收主服务器发送的 RDB 内容通常分为两种：

1. 当从服务器支持 "EOF" 功能时，主服务器可以把数据库中的数据以 RDB 协议格式通过 Socket 直接发送给服务器，免去了本地磁盘不必要的读写操作。
2. 否则，则接收主服务器生成的 RDB 文件并载入。

### 步骤 8：命令传播

命令传播上面也已经聊过，这里就略过了。

## 心跳检测

//TODO

## 参考文章

1. 《Redis 设计与实现（第二版） 黄健宏著》 - 第 15 章 复制
